<chapter type="" id="tl0604000000">
<title><content-text>Couche transport OSI</content-text></title>
<section type="ChapterIntroduction" id="tl0604000000">
<title><content-text>Présentation du chapitre</content-text></title>
<topic type="" id="tl0604000100">
<title><content-text>Présentation du chapitre</content-text></title>
<page type="OneColumn" id="tl0604000101">
<content-media type="StaticGraphic" id="cm3671155438"><title><content-text></content-text></title><media ref="tl0604000000/tl0604000000/tl0604000100/tl0604000101/cm3671155438.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604000000/tl0604000100/tl0604000101/cm3671155438text.xml"/></content-media>
<content-text><p>Les réseaux de données et Internet étayent le réseau humain en permettant aux individus de communiquer de façon transparente et fiable, aussi bien à l’échelon local qu’au niveau international. Nous pouvons, sur un même périphérique, utiliser des services aussi divers que les messageries électroniques, le Web ou les messageries instantanées pour envoyer des messages et recevoir des informations. Grâce aux applications de clients de messagerie, de navigateurs Internet et de clients de messagerie instantanée, nous sommes en mesure d’envoyer et de recevoir des messages et des informations par le biais d’ordinateurs et de réseaux.</p> <p>Dans chacun de ces types d’applications, les données sont empaquetées, transportées et livrées au démon du serveur approprié ou à l’application voulue sur le périphérique de destination. Le processus décrit dans la couche transport OSI accepte des données provenant de la couche application et les prépare pour les adresser à la couche réseau. La couche transport est globalement responsable du transfert de bout en bout des données d’application. </p> <p>Ce chapitre est consacré à l’étude du rôle de la couche transport dans le processus d’encapsulation des données d’application en vue de leur utilisation par la couche réseau. La couche transport remplit également d’autres fonctions : </p> <ul><li> Elle permet à de nombreuses applications de communiquer sur le réseau au même moment, sur un même périphérique ; </li> <li> Elle vérifie, si cela est nécessaire, que toutes les données sont reçues de façon fiable et dans l’ordre par l’application voulue ;</li> <li> Elle utilise des mécanismes de gestion des erreurs.</li></ul> <p><b>Objectifs pédagogiques</b></p> <p>À la fin de ce chapitre, vous pourrez :</p> <ul><li> Expliquer l’utilité de la couche transport</li> <li> Définir le rôle de la couche transport en matière de transfert, de bout en bout, de données entre applications</li> <li> Décrire le rôle de deux protocoles utilisés par la couche transport TCP/IP, à savoir les protocoles TCP et UDP</li> <li> Citer les principales fonctions de la couche transport, y compris en matière de fiabilité, d’adressage de ports et de segmentation</li> <li> Expliquer comment les protocoles TCP et UDP gèrent, chacun, des fonctions clés</li> <li> Reconnaître les situations où l’utilisation des protocoles TCP ou UDP s’impose et fournir des exemples d’applications utilisant chacun de ces protocoles</li></ul></content-text>
</page>
</topic>
</section>
<section type="" id="tl0604010000">
<title><content-text>Rôles de la couche transport</content-text></title>
<topic type="" id="tl0604010100">
<title><content-text>Objectif de la couche transport</content-text></title>
<page type="OneColumn" id="tl0604010101">
<content-media type="StaticGraphic" id="cm3362687121"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010101/cm3362687121.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010101/cm3362687121text.xml"/></content-media>
<content-text><p>La couche transport segmente les données et se charge du contrôle nécessaire au réassemblage de ces blocs de données dans les divers flux de communication. Pour ce faire, elle doit :</p> <ul><li> Effectuer un suivi des communications individuelles entre les applications résidant sur les hôtes source et de destination ;</li> <li> Segmenter les données et gérer chaque bloc individuel ;</li> <li> Réassembler les segments en flux de données d’application ;</li> <li> Identifier les différentes applications.</li></ul> <p><b>Suivi des conversations individuelles</b></p> <p>Tout hôte peut héberger plusieurs applications qui communiquent sur le réseau. Chacune de ces applications communique avec une ou plusieurs applications hébergées sur des hôtes distants. Il incombe à la couche transport de gérer les nombreux flux de communication entre ces applications.</p> <p><b>Segmentation des données</b></p> <p>Chaque application crée un flux de données à envoyer vers une application distante ; ces données doivent donc être préparées pour être expédiées sur le support sous forme de blocs faciles à gérer. Les protocoles de la couche transport décrivent les services qui segmentent les données provenant de la couche application. Il s’agit notamment de l’encapsulation devant s’appliquer à chaque bloc de données. Des en-têtes doivent être ajoutés à chaque bloc de données d’application au niveau de la couche transport pour indiquer à quelle communication il est associé. </p> <p><b>Reconstitution des segments</b></p> <p>L’hôte recevant les blocs de données peut les diriger vers l’application appropriée. Il faut en outre que ces blocs de données individuels puissent être réassemblés dans un flux de données complet utile à la couche application. Les protocoles intervenant au niveau de la couche transport gèrent la façon dont les informations d’en-tête de la couche transport servent à réassembler les blocs de données en flux qui seront transmis à la couche application.</p> <p><b>Identification des applications</b></p> <p>Pour que les flux de données atteignent les applications auxquelles ils sont destinés, la couche transport doit identifier l’application cible. Pour cela, la couche transport affecte un identificateur à chaque application. Les protocoles TCP/IP appellent cet identificateur un numéro de port. Chaque processus logiciel ayant besoin d’accéder au réseau se voit affecter un numéro de port unique sur son hôte. Ce numéro de port est inclus dans l’en-tête de la couche transport afin de préciser à quelle application ce bloc de données est associé.</p> <p>La couche transport fait le lien entre la couche application et la couche inférieure responsable de la transmission réseau. Cette couche accepte les données provenant de plusieurs conversations et les fait descendre vers les couches inférieures sous forme de blocs faciles à gérer pouvant au final faire l’objet d’un multiplexage sur le support.</p> <p>Les applications n’ont pas besoin de connaître les détails du fonctionnement du réseau utilisé. Les applications génèrent des données qui sont envoyées d’une application à une autre sans se soucier du type de l’hôte de destination, du type de support que les données doivent emprunter, du chemin suivi par ces données, de l’<content-link target="cg2172434056" type="glossary">encombrement</content-link> d’une liaison ni de la taille du réseau. </p> <p>En outre, les couches inférieures ignorent que plusieurs applications envoient des données sur le réseau. Leur responsabilité se limite à livrer les données au périphérique approprié. La couche transport trie ensuite ces blocs avant de les acheminer vers l’application voulue.</p> <p><b>Variabilité des besoins en données</b></p> <p>Parce que des applications différentes ont des besoins différents, il existe plusieurs protocoles pour la couche transport. Dans le cas de certaines applications, les segments doivent arriver dans un ordre bien précis pour être traités correctement. Pour d’autres applications, il faut que toutes les données soient arrivées pour qu’il soit possible de traiter n’importe laquelle d’entre elles. D’autres applications, enfin, tolèrent la perte d’une certaine quantité de données lors de la transmission sur le réseau. </p> <p>Les réseaux convergents actuels permettent à des applications dont les besoins en matière de transport sont très différents de communiquer sur le même réseau. Les différents protocoles s’appliquant à la couche transport reposent sur des règles variées qui permettent aux périphériques de satisfaire ces différents besoins en données.</p> <p>Certains protocoles n’offrent que des fonctions de base permettant de livrer efficacement les blocs de données entre les applications appropriées. Ces types de protocoles sont particulièrement utiles pour les applications dont les données sont sensibles aux retards.</p> <p>D’autres protocoles de la couche transport décrivent des processus offrant des fonctions supplémentaires, comme la remise fiable des données entre applications. Si ces fonctions supplémentaires assurent des communications plus robustes entre applications au niveau de la couche transport, elles entraînent une surcharge supplémentaire et sont plus gourmandes en ressources réseau.</p></content-text>
</page>
<page type="OneColumn" id="tl0604010102">
<content-media type="StaticGraphic" id="cm2907945546"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010102/cm2907945546.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010102/cm2907945546text.xml"/></content-media>
<content-text><p><b>Séparation de communications multiples</b></p> <p>Représentez-vous un ordinateur connecté à un réseau qui envoie et reçoit simultanément des courriels et messages instantanés, affiche des sites Web et passe un appel téléphonique par voix sur IP. Chacune de ces applications envoie des données sur le réseau et en reçoit simultanément. Pourtant, les données de l’appel téléphonique ne sont pas orientées vers le navigateur Web et le texte des messages instantanés ne finit pas dans un courriel.</p> <p>De plus, les informations contenues dans un courriel ou une page Web doivent avoir été intégralement reçues et affichées pour présenter un intérêt pour l’utilisateur. On considère certains retards comme acceptables pour veiller à ce que l’ensemble des informations soit reçu et présenté.</p> <p>Dans le cas d’une conversation téléphonique, l’absence de petits bocs peut par contre être considérée comme acceptable. Il est en effet possible de déduire le contenu audio manquant à partir du contexte de la conversation ou de demander à l’autre interlocuteur de répéter ce qu’il vient de dire. Ceci est jugé préférable aux retards que provoqueraient la gestion et le renvoi des segments manquants par le réseau. Dans notre exemple, c’est l’utilisateur, et non le réseau, qui gère la réexpédition ou la reconstitution des informations manquantes.</p></content-text>
</page>
<page type="OneColumn" id="tl0604010103">
<content-media type="StaticGraphic" id="cm6001954497"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010103/cm6001954497.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010103/cm6001954497text.xml"/></content-media>
<content-text><p>Comme nous vous l’avons expliqué dans un chapitre précédent, envoyer certains types de données (par exemple une vidéo) sur un réseau sous forme d’un flux de communication complet risque d’empêcher d’autres communications d’avoir lieu en même temps. Ceci rend également difficile la reprise sur erreur et la retransmission des données endommagées.</p> <p>Fractionner les données en blocs plus petits et envoyer ceux-ci de la source vers la destination permet à plusieurs communications différentes d’être entrelacées (de faire l’objet d’un multiplexage) sur le même réseau. </p> <p>La segmentation des données, conformément aux protocoles de la couche transport, permet d’envoyer et de recevoir des données tout en exécutant plusieurs applications simultanément sur un ordinateur. En l’absence de segmentation, une seule application, par exemple la lecture vidéo en continu, pourrait recevoir des données. Il serait impossible de recevoir des courriels, de parler sur une messagerie instantanée ou d’afficher des pages Web tout en visualisant la vidéo.</p> <p>Au niveau de la couche transport, chaque ensemble de blocs transitant entre une application source et une application de destination est appelé une conversation.</p> <p>Pour identifier chaque segment de données, la couche transport ajoute un en-tête contenant des données binaires à chaque bloc. Cet en-tête contient des champs de bits. Ce sont les valeurs contenues dans ces champs qui permettent aux différents protocoles de la couche transport d’exécuter des fonctions diverses.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604010200">
<title><content-text>Contrôle des conversations</content-text></title>
<page type="OneColumn" id="tl0604010201">
<content-media type="StaticGraphic" id="cm6028553598"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010200/tl0604010201/cm6028553598.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010200/tl0604010201/cm6028553598text.xml"/></content-media>
<content-text><p>Tous les protocoles de la couche transport ont des fonctions essentielles communes :</p> <p><b>Segmentation et reconstitution</b>. La plupart des réseaux limitent la quantité de données pouvant être incluses dans une même unité de données de protocole. La couche transport divise les données d’application en blocs de données d’une taille adéquate. Une fois ces blocs parvenus à destination, la couche transport réassemble les données avant de les envoyer vers l’application ou le service de destination.</p> <p><b>Multiplexage de conversations</b>. De nombreux services ou applications peuvent s’exécuter sur chaque hôte sur le réseau. Une adresse, appelée port, est affectée à chacun de ces services ou applications afin que la couche transport puisse déterminer à quel service ou application les données se rapportent.</p> <p>Dans le cadre des fonctions essentielles que sont la segmentation et la reconstitution des données, la couche transport fournit, en plus des informations contenues dans les en-têtes :</p> <ul><li> Des conversations avec connexion</li> <li> Un acheminement fiable</li> <li> Une reconstitution ordonnée des données</li> <li> Un contrôle du flux</li></ul></content-text>
</page>
<page type="OneColumn" id="tl0604010202">
<content-media type="StaticGraphic" id="cm5472742017"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010200/tl0604010202/cm5472742017.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010200/tl0604010202/cm5472742017text.xml"/></content-media>
<content-text><p><b>Établissement d’une session</b></p> <p>La couche transport est en mesure d’orienter la connexion en créant des sessions entre les applications. Ces connexions préparent les applications à communiquer entre elles avant le transfert des données. Dans ces sessions, il est possible de gérer avec précision les données d’une communication entre deux applications. </p> <p><b>Acheminement fiable</b></p> <p>Bien des circonstances peuvent entraîner la corruption ou la perte d’un bloc de données lors de son transfert sur le réseau. La couche transport veille à ce que tous les blocs atteignent leur destination en demandant au périphérique source de retransmettre les données qui ont pu se perdre.</p> <p><b>Livraison dans un ordre défini</b></p> <p>Étant donné que les réseaux fournissent une multitude de routes dont les délais de transmission varient, il se peut que les données arrivent dans le désordre. En numérotant et en ordonnant les segments, la couche transport s’assure que ces segments sont réassemblés dans le bon ordre. </p> <p><b>Contrôle du flux</b></p> <p>Les hôtes du réseau disposent de ressources limitées, par exemple en ce qui concerne la mémoire ou la bande passante. Quand la couche transport détermine que ces ressources sont surexploitées, certains protocoles peuvent demander à l’application qui envoie les données d’en réduire le flux. Ceci s’effectue au niveau de la couche transport en régulant la quantité de données que la source transmet sous forme de groupe. Le contrôle du flux contribue à prévenir la perte de segments sur le réseau et à rendre inutiles les retransmissions.</p> <p>Ces services vous seront expliqués plus en détail quand nous étudierons les protocoles dans un chapitre ultérieur.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604010300">
<title><content-text>Prise en charge de communications fiables</content-text></title>
<page type="OneColumn" id="tl0604010301">
<content-media type="StaticGraphic" id="cm2529899594"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010300/tl0604010301/cm2529899594.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010300/tl0604010301/cm2529899594text.xml"/></content-media>
<content-text><p>Souvenez-vous que la fonction première de la couche transport est de gérer les données d’application des conversations entre hôtes. Cependant, des applications différentes ont des exigences différentes pour leurs données, de sorte que des protocoles de transport différents ont été développés afin de satisfaire ces exigences.</p> <p>Un protocole de couche transport est en mesure d’assurer l’acheminement fiable des données. Dans le contexte des réseaux, la fiabilité consiste à veiller à ce que chaque bloc de données envoyé par la source parvienne à destination. Au niveau de la couche transport, les trois opérations de base en matière de fiabilité consistent à :</p> <ul><li> effectuer le suivi des données transmises ;</li> <li> accuser réception des données ;</li> <li> retransmettre toute donnée n’ayant pas fait l’objet d’un accusé de réception. </li></ul> <p>Pour cela, les processus de la couche transport de la source doivent effectuer le suivi de tous les blocs de données de chaque conversation et retransmettre les données pour lesquelles la destination n’a pas émis d’accusé de réception. La couche transport de l’hôte de destination doit également effectuer un suivi des données lors de leur arrivée et en accuser réception. </p> <p>Ces processus assurant la fiabilité augmentent la surcharge des ressources du réseau du fait des opérations d’accusé de réception, de suivi et de retransmission. Pour prendre en charge ces opérations assurant la fiabilité, un nombre plus important de <content-link target="cg9517726892" type="glossary">données de contrôle</content-link> est échangé entre les hôtes qui expédient et ceux qui reçoivent les données. Ces informations de contrôle sont contenues dans l’en-tête de la couche 4.</p> <p>Il s’établit ainsi un compromis entre la valeur accordée à la fiabilité et la charge qu’elle représente sur le réseau. Les développeurs d’applications doivent déterminer quel type de protocole de transport est approprié en fonction des exigences de leurs applications. Au niveau de la couche transport, il existe des protocoles qui précisent des méthodes choisies pour leur fiabilité, leur livraison garantie ou leur acheminement au mieux. Dans le contexte des réseaux, l’acheminement au mieux est considéré comme n’étant pas fiable car aucun accusé de réception ne confirme que les données sont arrivées à destination.</p> <p><b>Détermination du besoin de fiabilité</b></p> <p>Certaines applications, comme les bases de données, les pages Web et les courriels, ont besoin que toutes les données envoyées arrivent à destination dans leur état d’origine afin que ces données soient utiles. Toute donnée manquante risque de corrompre la communication en la rendant incomplète ou illisible. Cependant, ces applications sont conçues pour utiliser un protocole de couche transport qui implémente la fiabilité. On considère que cette surcharge supplémentaire pour le réseau est indispensable pour ces applications.</p> <p>D’autres applications tolèrent mieux la perte de petites quantités de données. Si, par exemple, un ou deux segments d’une lecture vidéo n’arrivent pas, cela ne fera que créer une interruption momentanée du flux. Ceci pourra se traduire par une distorsion de l’image que l’utilisateur ne remarquera peut-être même pas. </p> <p>Imposer une surcharge pour garantir la fiabilité de cette application risquerait de réduire l’utilité de l’application. L’image produite par une lecture vidéo en continu serait fortement dégradée si le périphérique de destination devait rendre compte des données perdues et retarder la lecture en continu le temps qu‘elles arrivent. Mieux vaut assurer un rendu aussi bon que possible de l’image à l’aide des segments qui arrivent et renoncer à la fiabilité. Si, pour une raison ou pour une autre, la fiabilité est un impératif, ces applications peuvent émettre des requêtes de vérification des erreurs et de retransmission.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604010400">
<title><content-text>TCP et UDP</content-text></title>
<page type="OneColumn" id="tl0604010401">
<content-media type="StaticGraphic" id="cm3689212369"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010400/tl0604010401/cm3689212369.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010400/tl0604010401/cm3689212369text.xml"/></content-media>
<content-text><p>Les deux protocoles de la suite de protocoles TCP/IP les plus couramment employés sont le protocole TCP (Transmission Control Protocol) et le protocole UDP (User Datagram Protocol). Ces deux protocoles gèrent les communications de nombreuses applications. Ce sont les fonctions spécifiques implémentées par chaque protocole qui les différencient. </p> <p><b>Protocole UDP (User Datagram Protocol)</b></p> <p>Le protocole UDP est un protocole simple, sans connexion, décrit par le document RFC 768. Il présente l’avantage d’imposer peu de surcharge pour l’acheminement des données. Les blocs de communication utilisés dans le protocole UDP sont appelés des <content-link target="cg9286423626" type="glossary">datagrammes</content-link>. Ces datagrammes sont envoyés « au mieux » par ce protocole de couche transport. </p> <p>Le protocole UDP est notamment utilisé par les applications suivantes :</p> <ul><li>Système de noms de domaine (DNS)</li> <li>Lecture vidéo en continu</li> <li>Voix sur IP (VoIP)</li></ul> <p><b>Protocole TCP (Transmission Control Protocol)</b></p> <p>Le protocole TCP est un protocole avec connexion décrit dans le document RFC 793. Le protocole TCP impose une surcharge pour accroître les fonctionnalités. Le protocole TCP spécifie d’autres fonctions, à savoir la livraison dans l’ordre, l’acheminement fiable et le <content-link target="cg3734498463" type="glossary">contrôle de flux</content-link>. Chaque segment du protocole TCP utilise 20 octets de surcharge dans l’en-tête pour encapsuler les données de la couche application alors que chaque segment du protocole UDP n’ajoute sur 8 octets de surcharge. Examinez le tableau comparatif ci-contre.</p> <p>Le protocole TCP est utilisé par les applications suivantes :</p> <ul><li>Navigateurs Web</li> <li>Courriel </li> <li>Transferts de fichiers</li></ul></content-text>
</page>
</topic>
<topic type="" id="tl0604010500">
<title><content-text>Adressage de ports</content-text></title>
<page type="OneColumn" id="tl0604010501">
<content-media type="StaticGraphic" id="cm9707646724"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010501/cm9707646724.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010501/cm9707646724text.xml"/></content-media>
<content-text><p><b>Identification des conversations</b></p> <p>Reprenons l’exemple précédent d’un ordinateur envoyant et recevant simultanément des courriels, des messages instantanés, des pages Web et un appel de voix sur IP. </p> <p>Les services basés sur les protocoles TCP et UDP effectuent le suivi des applications qui communiquent. Pour différencier les segments et les datagrammes de chaque application, les protocoles TCP et UDP utilisent chacun des champs d’en-tête identifiant ces applications de façon unique. Ces identificateurs uniques sont les numéros de port.</p> <p>L’en-tête de chaque segment ou datagramme contient un port source et un port de destination. Le numéro de port source est le numéro associé à l’application d’origine sur l’hôte local pour cette communication. Le numéro de port de destination est le numéro associé à l’application de destination sur l’hôte distant pour cette communication.</p> <p>L’affectation des numéros de port s’effectue de différentes façons selon que le message est une requête ou une réponse. Alors que les processus serveur se voient attribuer des numéros de port statiques, les clients choisissent dynamiquement un numéro de port pour chaque conversation.</p> <p>Lorsqu’une application cliente envoie une requête à une application serveur, le port de destination inclus dans l’en-tête est le numéro de port affecté au démon du service s’exécutant sur l’hôte distant. Le logiciel client doit savoir quel numéro de port est associé au processus serveur sur l’hôte distant. Ce numéro de port de destination est configuré par défaut ou manuellement. Ainsi, quand une application de navigateur Web envoie une requête à un serveur Web, le navigateur utilise le protocole TCP et le port numéro 80, sauf indication contraire. Ceci est dû au fait que le port 80 du protocole TCP est le port affecté par défaut aux applications de service Web. De nombreuses applications courantes ont des ports qui leur sont affectés par défaut. </p> <p>Le port source d’un en-tête de segment ou de datagramme d’une requête cliente est généré de façon aléatoire à partir des numéros de port supérieurs à 1023. Du moment que le numéro de port n’entre pas en conflit avec d’autres ports utilisés par le système, le client peut choisir n’importe quel numéro de port parmi la plage des numéros de port par défaut utilisés par le système d’exploitation. Le numéro de port fait office d’adresse de retour pour l’application envoyant la requête. La couche transport effectue le suivi du port et de l’application à l’origine de la requête afin que la réponse, quand elle sera envoyée, soit transmise à l’application appropriée. Le numéro de port de l’application envoyant la requête sert de numéro de port de destination dans la réponse renvoyée depuis le serveur. </p> <p>L’ensemble formé par le numéro de port de la couche transport et l’adresse IP de la couche réseau affectée à l’hôte identifie de façon unique un processus précis s’exécutant sur un périphérique hôte spécifique. Cet ensemble est appelé une interface de connexion. Il arrive parfois que les expressions « numéro de port » et « interface de connexion » soient utilisées l’une pour l’autre. Dans le cadre de ce cours, l’expression « interface de connexion » ne désigne que la combinaison unique formée par l’adresse IP et le numéro de port. Une paire d’interfaces de connexion, composée des adresses IP et des numéros de port source et de destination, est également unique et identifie une conversation entre deux hôtes.</p> <p>Par exemple, une requête de page Web HTTP envoyée à un serveur Web (port 80) s’exécutant sur un hôte avec une adresse IPv4 de couche 3 égale à 192.168.1.20 sera destinée à l’interface de connexion 192.168.1.20:80. </p> <p>Si le navigateur Web demandant la page Web s’exécute sur l’hôte 192.168.100.48 et si le numéro de port dynamique affecté au navigateur Web est 49152, l’interface de connexion de la page Web sera l’interface 192.168.100.48:49152.</p></content-text>
</page>
<page type="OneColumn" id="tl0604010502">
<content-media type="InteractiveGraphicRollovers" id="cm4489228163"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010502/cm4489228163.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010502/cm4489228163text.xml"/></content-media>
<content-text><p>L’<content-link target="cg6243132467" type="glossary">Internet Assigned Numbers Authority (IANA)</content-link> attribue les numéros de port. L’IANA est une agence de normalisation responsable de l’affectation de diverses normes d’adressage.</p> <p>Il existe différents types de numéros de port :</p> <p><b>Ports réservés</b> (numéros 0 à 1023). Ces numéros sont réservés à des services et applications. Ils sont généralement réservés à des applications de type HTTP (serveur Web), POP3/SMTP (serveur de messagerie) et Telnet. En définissant ces <content-link target="cg5184912009" type="glossary">ports réservés</content-link> pour une utilisation par des applications serveur, il est possible de programmer les applications clientes de façon à ce qu’elles demandent à être connectées à ce port précis et au service qui lui est associé.</p> <p><b>Ports inscrits</b> (numéros 1024 à 49151). Ces numéros de port sont affectés à des processus ou applications d’utilisateurs. Ces processus sont essentiellement des applications particulières qu’un utilisateur a choisi d’installer plutôt que des applications courantes qui recevraient un port réservé. Un client peut également sélectionner dynamiquement ces ports en tant que ports source lorsqu’ils ne sont pas utilisés par une ressource serveur.</p> <p><b>Ports privés ou dynamiques</b> (numéros 49152 à 65535). Également appelés ports éphémères, ces ports sont généralement affectés de façon dynamique à des applications clientes lorsqu’une connexion est initiée. Il est relativement rare pour un client de se connecter à un service par le biais d’un port dynamique ou privé (bien que certains programmes de partage de fichiers Peer to peer le fassent). </p> <p><b>Utilisation du protocole TCP et du protocole UDP</b></p> <p>Certaines applications utilisent le protocole TCP et le protocole UDP. En effet, la faible surcharge du protocole UDP permet au service DNS de gérer très rapidement de nombreuses requêtes de clients. Parfois, cependant, l’envoi des informations demandées exige la fiabilité du protocole TCP. Dans ce cas, le port réservé 53 est utilisé par les deux protocoles en association avec ce service.</p> <p><b>Liens</b></p> <p>Vous trouverez une liste des numéros de port actuels sur le site <content-link target="http://www.iana.org/assignments/port-numbers" type="external">http://www.iana.org/assignments/port-numbers</content-link>.</p></content-text>
</page>
<page type="OneColumn" id="tl0604010503">
<content-media type="InteractiveGraphicRollovers" id="cm6760618296"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010503/cm6760618296.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010503/cm6760618296text.xml"/></content-media>
<content-text><p>Il est parfois nécessaire de savoir quelles connexions TCP actives sont ouvertes et s’exécutent sur un hôte en réseau. <span class="cmd"><b>Netstat</b></span> est un important utilitaire réseau permettant de vérifier ces connexions. <span class="cmd"><b>Netstat</b></span> répertorie le protocole utilisé, l’adresse et le numéro de port locaux, l’adresse et le numéro de port distants ainsi que l’état de la connexion. </p> <p>Les connexions TCP inexpliquées peuvent poser un risque de sécurité majeur. Elles peuvent en effet signaler que quelque chose ou quelqu’un est connecté à l’hôte local. En outre, les connexions TCP inutiles consomment des ressources système importantes et ralentissent donc les performances de l’hôte. Il est conseillé d’utiliser <span class="cmd"><b>Netstat</b></span> pour examiner les connexions ouvertes sur un hôte lorsque les performances semblent peu satisfaisantes. </p> <p>La commande <span class="cmd"><b>netstat</b></span> dispose de nombreuses options utiles.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604010600">
<title><content-text>Segmentation et reconstitution : diviser et conquérir</content-text></title>
<page type="OneColumn" id="tl0604010601">
<content-media type="StaticGraphic" id="cm5820324751"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010600/tl0604010601/cm5820324751.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010600/tl0604010601/cm5820324751text.xml"/></content-media>
<content-text><p>Dans un chapitre précédent, nous vous avons expliqué que les unités de données de protocole sont élaborées en faisant transiter les données d’une application par divers protocoles afin de créer des unités de données de protocole qui sont ensuite transmises sur le support. Une fois les données parvenues sur l’hôte de destination, le processus est inversé jusqu’à ce que les données puissent être communiquées à l’application.</p> <p>Certaines applications transmettent de très importants volumes de données pouvant parfois atteindre plusieurs gigaoctets. Transmettre l’ensemble de ces données en un envoi massif serait peu pratique car aucun autre trafic ne pourrait être transmis sur le réseau pendant l’envoi de ces données. De plus, l’envoi d’une grosse quantité de données peut prendre de plusieurs minutes à plusieurs heures. En outre, si une erreur se produisait, l’ensemble du fichier de données serait perdu ou devrait être réexpédié. La mémoire tampon des périphériques réseau ne serait pas suffisante pour stocker autant de données pendant leur transmission ou leur réception. La limite varie selon la technologie réseau employée et le support physique particulier qui est utilisé.</p> <p><b>Diviser les données d’application en blocs permet de s’assurer que les données sont transmises en tenant compte des limites du support et que les données provenant d’applications différentes peuvent faire l’objet d’un multiplexage sur le support.</b></p> <p><b>Les protocoles TCP et UDP traitent différemment la segmentation.</b></p> <p>Avec le protocole TCP, chaque en-tête de segment contient un numéro d’ordre. Ce numéro d’ordre permet aux fonctions de la couche transport, au niveau de l’hôte de destination, de réassembler les segments dans l’ordre de leur envoi. L’application de destination peut ainsi disposer des données sous la forme exacte voulue par l’expéditeur.</p> <p>Bien que les services utilisant le protocole UDP effectuent également un suivi des conversations entre les applications, ils ne prêtent pas attention à l’ordre dans lequel les informations ont été transmises ni au maintien de la connexion. Un en-tête UDP ne contient pas de numéro d’ordre. La conception du protocole UDP est plus simple et produit moins de surcharge que le protocole TCP, de sorte que le transfert de données est plus rapide. </p> <p>Il se peut que les informations arrivent dans un ordre différent de celui dans lequel elles ont été transmises car les différents paquets peuvent emprunter plusieurs chemins sur le réseau. Les applications qui utilisent le protocole UDP doivent tolérer le fait que les données peuvent arriver dans un ordre différent de celui dans lequel elles ont été envoyées.</p></content-text>
</page>
<page type="OneColumn" id="tl0604010602">
<content-media type="ActivityPKA" id="cm7581778394"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010600/tl0604010602/cm7581778394/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604010000/tl0604010600/tl0604010602/cm7581778394/icontext.xml"/></content-media>
<content-text><p>Cet exercice va vous donner l’occasion de plonger « au coeur » des paquets afin d’observer la façon dont les protocoles DNS et HTTP utilisent les numéros de port. </p><p><b>Cliquez sur l’icône de Packet Tracer pour démarrer l’exercice Packet Tracer.</b></p></content-text>
</page>
</topic>
</section>
<section type="" id="tl0604020000">
<title><content-text>Protocole TCP : des communications fiables</content-text></title>
<topic type="" id="tl0604020100">
<title><content-text>TCP : fiabilisation des conversations</content-text></title>
<page type="OneColumn" id="tl0604020101">
<content-media type="InteractiveGraphicRollovers" id="cm7307395386"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020100/tl0604020101/cm7307395386.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020100/tl0604020101/cm7307395386text.xml"/></content-media>
<content-text><p><b>La fiabilité est le principal élément différentiateur entre les protocoles TCP et UDP. </b>La fiabilité des communications TCP est assurée à l’aide de sessions avec connexion. Avant qu’un hôte utilisant le protocole TCP n’envoie de données à un autre hôte, la couche transport initie un processus destiné à établir une connexion avec la destination. Cette connexion rend possible le suivi d’une session, ou d’un flux de communication, entre les hôtes. Ce processus veille à ce que chaque hôte soit notifié de la communication et qu’il y soit prêt. Une conversation TCP complète exige l’établissement d’une session entre les hôtes dans les deux directions.</p> <p>Lorsqu’une session a été établie, la destination envoie des accusés de réception à la source pour les segments qu’elle reçoit. Ces accusés constituent l’élément de base de la fiabilité dans la session TCP. Quand la source reçoit un accusé de réception, elle sait que les données ont bien été livrées et qu’elle peut cesser d’en effectuer le suivi. Si la source ne reçoit pas d’accusé de réception dans un délai prédéterminé, elle retransmet ces données vers la destination. </p> <p>La surcharge provoquée par l’utilisation du protocole TCP provient en partie du trafic réseau généré par les accusés de réception et les retransmissions. L’établissement des sessions crée une surcharge prenant la forme d’un échange supplémentaire de segments. Une surcharge supplémentaire provoquée par la nécessité d’effectuer un suivi des segments pour lesquels on attend un accusé de réception et par le processus de retransmission pèse également sur les hôtes individuels.</p> <p>La fiabilité est assurée par le recours à des champs du segment TCP qui ont, chacun, une fonction précise ainsi que l’illustre la figure ci-contre. Nous étudierons ces champs plus tard dans cette section.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604020200">
<title><content-text>Processus serveur TCP</content-text></title>
<page type="OneColumn" id="tl0604020201">
<content-media type="InteractiveGraphicRollovers" id="cm1111794604"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020200/tl0604020201/cm1111794604.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020200/tl0604020201/cm1111794604text.xml"/></content-media>
<content-text><p>Comme nous l’avons vu dans le chapitre précédent, les processus applicatifs s’exécutent sur des serveurs. Ces processus attendent qu’un client lance une demande d’information ou d’autres services.</p> <p>Chaque processus applicatif qui s’exécute sur le serveur est configuré par défaut, ou manuellement par un administrateur système, pour utiliser un numéro de port. <b>Deux services ne peuvent pas être affectés au même numéro de port d’un serveur particulier au sein des mêmes services de la couche transport. </b>Il est impossible qu’une application de serveur Web et une application de transfert de fichiers s’exécutant sur un hôte soient toutes deux configurées pour utiliser le même port (par exemple le port TCP 8080). Quand une application de serveur active est affectée à un port spécifique, on considère que ce port est « ouvert » sur le serveur. Ceci signifie que la couche transport accepte et traite les segments adressés à ce port. Toute demande entrante d’un client qui est adressée à l’interface de connexion correcte est acceptée et les données sont transmises à l’application de serveur. De nombreux ports peuvent être ouverts simultanément sur un serveur, chacun étant destiné à une application de serveur active. Il est courant qu’un serveur fournisse plusieurs services simultanément, par exemple en tant que serveur Web et en tant que serveur FTP.</p> <p>Limiter l’accès au serveur aux seuls ports associés aux services et applications devant être accessibles aux demandeurs autorisés est un moyen d’améliorer la sécurité sur le serveur. </p> <p>La figure ci-contre illustre l’affectation typique de ports source et de destination dans des opérations clients/serveurs TCP.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604020300">
<title><content-text>Établissement et fermeture d’une connexion TCP</content-text></title>
<page type="OneColumn" id="tl0604020301">
<content-media type="InteractiveGraphicRollovers" id="cm5977147278"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020300/tl0604020301/cm5977147278.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020300/tl0604020301/cm5977147278text.xml"/></content-media>
<content-text><p>Lorsque deux hôtes communiquent à l’aide du protocole TCP, une connexion est établie avant que les données ne puissent être échangées. Une fois la communication terminée, les sessions sont fermées et il est mis fin à la connexion. Les mécanismes de connexion et de sessions permettent la fonction de fiabilité de TCP.</p> <p><b>Consultez la figure ci-contre pour découvrir les étapes de l’établissement et de la fermeture d’une connexion TCP.</b></p> <p>L’hôte effectue un suivi de chaque segment de données au sein d’une session et échange des informations sur les données reçues par chaque hôte grâce aux informations contenues dans l’en-tête TCP. </p> <p>Chaque connexion implique des flux (ou sessions) de communication unidirectionnels pour établir et fermer le processus TCP entre les périphériques finaux. Pour établir la connexion, l’hôte effectue une <content-link target="cg1855565274" type="glossary">connexion en trois étapes</content-link>. Les bits de contrôle de l’en-tête TCP indiquent la progression et l’état de la connexion. La connexion en trois étapes :</p> <ul><li> Vérifie que le périphérique de destination est bien présent sur le réseau ;</li> <li> S’assure que le périphérique de destination a un service actif et qu’il accepte les requêtes sur le numéro de port de destination que le client qui démarre la session a l’intention d’utiliser ;</li> <li> Informe le périphérique de destination que le client source entend établir une session de communication sur ce numéro de port.</li></ul> <p>Dans les connexions TCP, l’hôte faisant office de client initie la session auprès du serveur. Pour comprendre le processus de connexion en trois étapes, il convient d’examiner les différentes valeurs échangées par les deux hôtes. Les trois étapes de l’établissement d’une connexion TCP sont les suivantes :</p> <p>1. Le client initiant la session envoie au serveur un segment contenant un numéro d’ordre initial faisant office de requête afin de commencer une session de communication.</p> <p>2. Le serveur répond par un segment contenant un numéro d’accusé de réception égal au numéro d’ordre reçu plus 1, ainsi que son propre numéro d’ordre de synchronisation. Ce numéro est supérieur au numéro d’ordre car l’ACK est toujours l’octet suivant attendu. Ce numéro d’accusé de réception permet au client de relier la réponse au segment d’origine envoyé au serveur. </p> <p>3. Le client initiant la session répond par un numéro d’accusé de réception égal au numéro d’ordre reçu plus 1. Ceci achève le processus d’établissement de la connexion.</p> <p>Dans l’en-tête du segment TCP se trouvent six champs de 1 bit contenant des informations de contrôle qui servent à gérer les processus TCP. Il s’agit des champs : </p> <p><b>URG </b>: pointeur de données urgentes valide ;</p> <p><b>ACK </b>: champ d’accusé de réception valide ;</p> <p><b>PSH </b>: fonction de livraison des données sans attendre le remplissage des tampons (Push) ;</p> <p><b>RST </b>: réinitialisation de la connexion ;</p> <p><b>SYN </b>: synchronisation des <content-link target="cg2460438518" type="glossary">numéros d’ordre</content-link> ;</p> <p><b>FIN </b>: plus d’envoi de données par l’expéditeur.</p> <p>Ces champs sont appelés des indicateurs car la valeur de chaque champ n’est que de 1 bit et que, donc, ils ne peuvent prendre que deux valeurs, à savoir 1 ou 0. Quand une valeur de bit est définie sur 1, ceci indique le type d’informations de contrôle contenues dans le segment.</p> <p>Un processus en quatre étapes permet d’échanger les indicateurs pour mettre fin à une connexion TCP.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604020400">
<title><content-text>Connexion TCP en trois étapes</content-text></title>
<page type="OneColumn" id="tl0604020401">
<content-media type="StaticGraphic" id="cm3626205190"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020401/cm3626205190.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020401/cm3626205190text.xml"/></content-media>
<content-text><p>Les résultats Wireshark vous permettent d’examiner le fonctionnement d’une connexion TCP en trois étapes :</p> <p><b>Étape 1</b></p> <p>Un client TCP initie une connexion en trois étapes en envoyant un segment contenant l’indicateur de contrôle SYN (Synchronize Sequence Number) qui indique une valeur initiale dans le champ de numéro d’ordre de l’en-tête. Cette valeur initiale du numéro d’ordre, appelée ISN (Initial Sequence Number), est choisie de façon aléatoire et sert à commencer le suivi du flux de données entre le client et le serveur pour cette session. L’ISN figurant dans l’en-tête de chaque segment est incrémenté de un pour chaque octet de données envoyé par le client au serveur tandis que la conversation de données se poursuit.</p> <p>Comme l’illustre la figure ci-contre, le résultat d’un analyseur de protocole affiche l’indicateur de contrôle SYN et le numéro d’ordre relatif. </p> <p>L’indicateur de contrôle SYN est défini et le numéro d’ordre relatif est égal à 0. Bien que dans le graphique l’analyseur de protocole indique les valeurs relatives des numéros d’ordre et d’accusés de réception, les vraies valeurs sont des nombres binaires de 32 bits. Nous pouvons déterminer les nombres réels envoyés dans les en-têtes de segments en examinant le volet des octets de paquet. Ici, vous pouvez voir les quatre octets représentés en <content-link target="cg5013036290" type="glossary">hexadécimal</content-link>.</p></content-text>
</page>
<page type="OneColumn" id="tl0604020402">
<content-media type="StaticGraphic" id="cm3903872438"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020402/cm3903872438.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020402/cm3903872438text.xml"/></content-media>
<content-text><p><b>Étape 2</b></p> <p>Le serveur TCP doit accuser la réception du segment SYN provenant du client pour établir la session du client vers le serveur. Pour cela, le serveur renvoie au client un segment accompagné de l’indicateur ACK indiquant que le numéro d’accusé de réception est valide. Grâce à cet indicateur présent dans le segment, le client identifie ceci comme un accusé de réception indiquant que le serveur a reçu le SYN du client TCP. </p> <p>La valeur du champ du numéro d’<content-link target="cg3136986209" type="glossary">accusé de réception</content-link> est égale au numéro d’ordre initial du client plus 1. Ceci établit une session du client vers le serveur. L’indicateur ACK demeurera défini pour le reste de la session. Souvenez-vous qu’en fait la communication entre le client et le serveur est composé de deux sessions unidirectionnelles : une allant du client vers le serveur et l’autre du serveur vers le client. Dans cette deuxième étape de la connexion en trois étapes, le serveur doit initier la réponse du serveur au client. Pour lancer cette session, le serveur utilise l’indicateur SYN comme le client l’a fait. Il inclut l’indicateur de contrôle SYN dans l’en-tête pour établir une session du serveur vers le client. L’indicateur SYN précise que la valeur initiale du champ de numéro d’ordre se trouve dans l’en-tête. Cette valeur servira à effectuer le suivi du flux de données dans cette session en retour du serveur vers le client.</p> <p>Comme l’illustre la figure ci-contre, les résultats de l’analyseur de protocole montrent que les indicateurs de contrôle ACK et SYN sont définis et que les numéros relatifs d’ordre et d’accusé de réception sont affichés.</p></content-text>
</page>
<page type="OneColumn" id="tl0604020403">
<content-media type="StaticGraphic" id="cm9650257006"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020403/cm9650257006.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020403/cm9650257006text.xml"/></content-media>
<content-text><p><b>Étape 3</b></p> <p>Enfin, le client TCP répond à l’aide d’un segment contenant un ACK qui constitue la réponse au SYN TCP envoyé par le serveur. Ce segment ne contient pas de données de l’utilisateur. La valeur du champ du numéro d’accusé de réception est supérieure de 1 au numéro d’ordre initial reçu du serveur. Quand les deux sessions sont établies entre le client et le serveur, tous les segments supplémentaires échangés dans cette communication comportent l’indicateur ACK défini.</p> <p>Comme l’illustre la figure ci-contre, les résultats de l’analyseur de protocole montrent que les indicateurs de contrôle ACK et SYN sont définis et que les numéros relatifs d’ordre et d’accusé de réception sont affichés. </p> <p>Il est possible de sécuriser le réseau de données en :</p> <ul><li> Refusant l’établissement de sessions TCP ;</li> <li> Autorisant uniquement l’établissement de sessions pour des services spécifiques ;</li> <li> Autorisant uniquement le trafic faisant déjà partie de sessions établies.</li></ul> <p>Ces mesures de sécurité peuvent être implémentées pour toutes les sessions TCP ou uniquement pour certaines sessions sélectionnées.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604020500">
<title><content-text>Fermeture d’une session TCP</content-text></title>
<page type="OneColumn" id="tl0604020501">
<content-media type="StaticGraphic" id="cm5895607750"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020500/tl0604020501/cm5895607750.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020500/tl0604020501/cm5895607750text.xml"/></content-media>
<content-text><p>Pour fermer une connexion, il faut que l’indicateur de contrôle <content-link target="cg3765151821" type="glossary">FIN (finish)</content-link> de l’en-tête du segment soit défini. Pour mettre fin à chaque session TCP unidirectionnelle, on utilise un échange en deux étapes constituée d’un segment FIN et d’un segment ACK. Pour mettre fin à une seule conversation TCP, quatre échanges sont nécessaires pour mettre fin aux deux sessions. <b>Remarque</b> : les termes client et serveur sont utilisés ici pour simplifier l’explication, mais le processus de fermeture peut être initié par n’importe lequel des deux hôtes terminant la session.</p> <p>1. Quand le client n’a plus de données à envoyer dans le flux, il envoie un segment dont l’indicateur FIN est défini.</p> <p>2. Le serveur envoie un segment ACK pour informer de la bonne réception du segment FIN afin de fermer la session du client au serveur.</p> <p>3. Le serveur envoie un segment FIN au client pour mettre fin à la session du serveur au client.</p> <p>4. Le client répond à l’aide d’un segment ACK pour accuser réception du segment FIN envoyé par le serveur.</p> <p>Quand l’extrémité cliente de la session n’a plus aucune donnée à transférer, elle définit l’indicateur FIN dans l’en-tête d’un segment. Ensuite, l’extrémité serveur de la connexion envoie un segment normal contenant des données dont l’indicateur ACK est défini en utilisant le numéro d’accusé de réception, confirmant ainsi que tous les octets de données ont été reçus. Quand la réception de tous les segments a été confirmée, la session est fermée.</p> <p>La session dans l’autre sens est fermée selon le même processus. Le récepteur indique qu’il n’y a plus de données à envoyer en définissant l’indicateur FIN dans l’en-tête d’un segment envoyé à la source. Un accusé de réception confirme que tous les octets de données ont été reçus et que cette session, à son tour, se ferme.</p> <p>Comme l’illustre la figure ci-contre, les indicateurs de contrôle FIN et ACK sont définis dans l’en-tête du segment et ferment donc une session HTTP.</p> <p>Il est également possible de fermer la connexion à l’aide d’une connexion en trois étapes. Quand le client n’a plus de données à envoyer, il envoie un segment FIN au serveur. Si le serveur n’a plus de données à envoyer, il peut répondre en définissant les indicateurs FIN et ACK simultanément et en combinant ainsi deux étapes en une. Le client répond par un segment ACK.</p></content-text>
</page>
<page type="OneColumn" id="tl0604020502">
<content-media type="ActivityPKA" id="cm2215239984"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020500/tl0604020502/cm2215239984/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604020000/tl0604020500/tl0604020502/cm2215239984/icontext.xml"/></content-media>
<content-text><p>Dans cet exercice, vous allez étudier la connexion en trois étapes pour l’établissement d’une session et le processus TCP de fermeture d’une session. De nombreux protocoles d’applications utilisent le protocole TCP. Visualiser les processus d’établissement et de fermeture avec Packet Tracer sera donc utile pour renforcer votre compréhension du sujet.</p><p><b>Cliquez sur l’icône Packet Tracer pour lancer l’exercice Packet Tracer.</b></p></content-text>
</page>
</topic>
</section>
<section type="" id="tl0604030000">
<title><content-text>Gestion des sessions TCP</content-text></title>
<topic type="" id="tl0604030100">
<title><content-text>Réassemblage de segments TCP</content-text></title>
<page type="OneColumn" id="tl0604030101">
<content-media type="StaticGraphic" id="cm1839101137"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030100/tl0604030101/cm1839101137.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030100/tl0604030101/cm1839101137text.xml"/></content-media>
<content-text><p><b>Réordonnancement des segments dans l’ordre de leur transmission</b></p> <p>Quand des services envoient des données à l’aide du protocole TCP, il arrive que les segments parviennent à destination dans le désordre. Pour que le destinataire puisse comprendre le message d’origine, il faut que les données contenues dans ces segments soient réagencées dans leur ordre d’origine. Pour cela, des numéros d’ordre sont affectés à l’en-tête de chaque paquet. </p> <p>Lors de la configuration de la session, un numéro d’ordre initial, ou ISN, est défini. Ce numéro d’ordre initial représente la valeur de départ des octets de cette session qui seront transmis à l’application réceptrice. Lors de la transmission des données pendant la session, le numéro d’ordre est incrémenté du nombre d’octets ayant été transmis. Ce suivi des octets de données permet d’identifier chaque segment et d’en accuser réception individuellement. Il est ainsi possible d’identifier les segments manquants. </p> <p>Les numéros d’ordre des segments assurent la fiabilité en indiquant comment réassembler et réordonnancer les segments reçus, ainsi que l’illustre la figure ci-contre. </p> <p>Le processus TCP récepteur place les données d’un segment dans une mémoire tampon de réception. Les segments sont remis dans l’ordre correct et sont transmis à la couche application une fois qu’ils ont été réassemblés. Tous les segments reçus dont les numéros d’ordre ne sont pas contigus sont conservés en vue d’un traitement ultérieur. Ces segments sont ensuite traités quand les segments contenant les octets manquants sont reçus.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604030200">
<title><content-text>Accusé de réception TCP avec fenêtrage</content-text></title>
<page type="OneColumn" id="tl0604030201">
<content-media type="StaticGraphic" id="cm8066369059"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030200/tl0604030201/cm8066369059.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030200/tl0604030201/cm8066369059text.xml"/></content-media>
<content-text><p><b>Confirmation de la réception des segments</b></p> <p>L’une des fonctions du protocole TCP est de veiller à ce que chaque segment atteigne sa destination. Les services TCP sur l’hôte de destination accusent réception des données reçues à l’application source. </p> <p>Le numéro d’ordre et le numéro d’accusé de réception de l’en-tête du segment sont utilisés ensemble pour confirmer la réception des octets de données contenus dans les segments. Le numéro d’ordre est le nombre relatif d’octets qui ont été transmis dans cette session plus 1 (qui est le numéro du premier octet de données dans le segment actuel). TCP utilise le numéro d’accusé de réception des segments renvoyés à la source pour indiquer l’octet suivant de cette session que le récepteur s’attend à recevoir. C’est ce que l’on appelle un <i>accusé de réception prévisionnel</i>. </p> <p>La source est informée que la destination a reçu tous les octets de ce flux de données jusqu’à l’octet indiqué par le numéro d’accusé de réception, mais sans inclure ce dernier. L’hôte expéditeur est censé envoyer un segment qui utilise un numéro d’ordre égal au numéro d’accusé de réception.</p> <p>Souvenez-vous qu’en fait chaque connexion est composée de deux sessions unidirectionnelles. Les numéros d’ordre et les numéros d’accusé de réception sont échangés dans les deux sens.</p> <p>Dans l’exemple de la figure ci-contre, l’hôte de gauche envoie des données à l’hôte de droite. Il envoie un segment contenant 10 octets de données pour cette session et un numéro d’ordre égal à 1 dans l’en-tête. </p> <p>L’hôte récepteur sur la droite reçoit le segment au niveau de la couche 4 et détermine que le numéro d’ordre est 1 et qu’il y a 10 octets de données. L’hôte renvoie alors un segment à l’hôte de gauche pour accuser la réception de ces données. Dans ce segment, l’hôte définit le numéro d’accusé de réception à 11 pour indiquer que le prochain octet de données qu’il s’attend à recevoir dans cette session est l’octet numéro 11. Notez que la valeur d’accusé de réception dans l’hôte source reste 1 pour indiquer que le segment fait partie d’une conversation en cours et que le numéro figurant dans le champ du numéro d’accusé de réception est valide.</p> <p>Quand l’hôte émetteur sur la gauche reçoit cet accusé de réception, il peut envoyer le segment suivant contenant des données pour cette session commençant par l’octet numéro 11.</p> <p>Dans notre exemple, si l’hôte émetteur devait attendre un accusé de réception pour chaque ensemble de 10 octets reçu, le réseau subirait une forte surcharge. Pour réduire la surcharge de ces accusés de réception, plusieurs segments de données peuvent être envoyés à l’avance et faire l’objet d’un accusé de réception par un unique message TCP en retour. Cet accusé de réception contient un numéro d’accusé de réception basé sur le nombre total d’octets reçus dans la session. </p> <p>Prenons l’exemple d’un numéro d’ordre de début égal à 2000. Si 10 segments de 1 000 octets chacun étaient reçus, un numéro d’accusé de réception de 12000 serait renvoyé à la source. </p> <p>La quantité de données qu’une source peut transmettre avant de devoir recevoir un accusé de réception est appelée la <content-link target="cg6791355311" type="glossary">taille de fenêtre</content-link>. La taille de fenêtre est un champ de l’en-tête TCP qui permet de gérer les données perdues et le contrôle du flux.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604030300">
<title><content-text>Retransmission TCP</content-text></title>
<page type="OneColumn" id="tl0604030301">
<content-media type="AnimationPartialScreen" id="cm1108087151"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030300/tl0604030301/cm1108087151.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030300/tl0604030301/cm1108087151text.xml"/></content-media>
<content-text><p><b>Traitement des pertes de segments</b></p> <p>Tous les réseaux, même les mieux conçus, connaissent parfois des pertes de données. Le protocole TCP fournit donc des méthodes de traitement de ces pertes de segments. Parmi elles se trouve un mécanisme de retransmission des segments contenant des données sans accusé de réception.</p> <p>En général, un service sur l’hôte de destination utilisant le protocole TCP ne génère d’accusé de réception que pour les séquences contiguës d’octets. Si un ou plusieurs segments sont manquants, seules les données des segments qui complètent le flux donnent lieu à l’émission d’accusés de réception. </p> <p>Par exemple, en cas de réception de segments dont les numéros d’ordre vont de 1500 à 3000 et de 3400 à 3500, le numéro de l’accusé de réception sera 3001. Ceci s’explique par le fait que certains segments n’ont pas été reçus entre les numéros d’ordre 3001 et 3399.</p> <p>Quand le protocole TCP sur l’hôte source n’a pas reçu d’accusé de réception après un délai prédéterminé, il revient au dernier numéro d’accusé de réception et retransmet les données depuis ce point.</p> <p>Le processus de retransmission n’est pas spécifié par le document RFC et il incombe à l’implémentation particulière du protocole TCP de le déterminer. </p> <p>Dans une implémentation TCP classique, un hôte peut transmettre un segment, placer une copie du segment dans une file d’attente de retransmission et lancer un minuteur. Quand l’accusé de réception des données est reçu, le segment est supprimé de la file d’attente. Si l’accusé de réception n’est pas reçu avant l’écoulement du délai prévu, le segment est retransmis. </p> <p>Notre animation illustre la retransmission des segments perdus.</p> <p>Aujourd’hui, les hôtes utilisent également une fonction facultative appelée <i>accusés de réception sélectifs</i>. Si les deux hôtes prennent en charge les accusés de réception sélectifs, la destination peut accuser réception des octets de segments ne se suivant pas et l’hôte ne retransmettra que les données manquantes.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604030400">
<title><content-text>Contrôle de l’encombrement sur TCP - Réduction de la perte de segments</content-text></title>
<page type="OneColumn" id="tl0604030401">
<content-media type="StaticGraphic" id="cm3515319049"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030400/tl0604030401/cm3515319049.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030400/tl0604030401/cm3515319049text.xml"/></content-media>
<content-text><p><b>Contrôle de flux</b></p> <p>Le protocole TCP inclut également des mécanismes de contrôle de flux. Le contrôle de flux contribue à la fiabilité des transmissions TCP en réglant le taux effectif de flux de données entre les deux services de la session. Quand la source est informée que la quantité de données spécifiée dans les segments a été reçue, elle peut continuer à envoyer plus de données pour cette session.</p> <p>Ce champ Taille de fenêtre dans l’en-tête TCP précise la quantité de données pouvant être transmise avant qu’il ne soit nécessaire de recevoir un accusé de réception. La taille de fenêtre initiale est déterminée lors du démarrage de la session par l’intermédiaire de la connexion en trois étapes.</p> <p>Le mécanisme de retour d’information TCP règle le taux de transmission effectif des données sur le flux maximum que le réseau et le périphérique de destination peuvent prendre en charge sans perte. Le TCP s’efforce de gérer le taux de retransmission de façon à ce que toutes les données soient reçues et que les retransmissions soient limitées au maximum. </p> <p>La figure ci-contre présente une représentation simplifiée de la taille de fenêtre et des accusés de réception. Dans cet exemple, la taille de fenêtre initiale d’une session TCP représentée est définie à 3000 octets. Lorsque l’expéditeur a transmis 3 000 octets, il attend l’accusé de réception de ces octets avant de transmettre d’autres segments de cette session. </p> <p>Une fois que l’expéditeur a reçu l’accusé de réception du destinataire, il peut transmettre 3 000 octets supplémentaires. </p> <p>Pendant le délai d’attente de réception de l’accusé de réception, l’expéditeur n’envoie pas de segment supplémentaire pour cette session. Quand le réseau est encombré ou que les ressources de l’hôte récepteur subissent une forte pression, le délai peut augmenter. Plus ce délai s’allonge, plus le taux de transmission effectif des données de cette session diminue. La diminution du taux de transfert des données contribue à réduire les conflits d’utilisation des ressources.</p></content-text>
</page>
<page type="OneColumn" id="tl0604030402">
<content-media type="StaticGraphic" id="cm7520409457"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030400/tl0604030402/cm7520409457.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030400/tl0604030402/cm7520409457text.xml"/></content-media>
<content-text><p><b>Réduction de la taille de fenêtre</b></p> <p>L’utilisation de tailles de fenêtres dynamiques permet également de contrôler le flux de données. Quand les ressources réseau sont soumises à de fortes contraintes, le protocole TCP peut réduire la taille de fenêtre afin d’imposer l’envoi plus fréquent d’accusés de réception pour les segments reçus. Ceci a pour effet de ralentir le taux de transmission car la source attend des accusés de réception des données plus fréquents.</p> <p>L’hôte TCP destinataire envoie la valeur de la taille de fenêtre à l’expéditeur TCP afin de lui indiquer le nombre d’octets qu’il est préparé à recevoir dans le cadre de cette session. Si la destination doit ralentir le taux de communication parce que la mémoire tampon est limitée, elle peut envoyer une valeur de taille de fenêtre plus petite à la source en l’intégrant à un accusé de réception.</p> <p>Comme l’illustre la figure ci-contre, si un hôte récepteur subit un encombrement, il peut répondre à l’hôte expéditeur avec un segment dont la taille de fenêtre est réduite. Ce graphique montre que l’un des segments a été perdu. Dans cette conversation, le destinataire a changé le champ de fenêtre dans l’en-tête TCP des segments renvoyés en le ramenant de 3000 à 1500. L’expéditeur a donc été obligé de réduire la taille de fenêtre à 1500. </p> <p>Quand un certain temps se sera écoulé sans perte de données ni contraintes excessives sur les ressources, le destinataire pourra recommencer à augmenter la taille de fenêtre. Ceci réduit la surcharge du réseau car un moins grand nombre d’accusés de réception doit être envoyé. La taille de fenêtre continuera à augmenter jusqu’à ce que des données soient à nouveau perdues, ce qui entraînera une réduction de la taille de fenêtre.</p> <p>Ces augmentations et réductions dynamiques de la taille de fenêtre constituent un processus continu dans le protocole TCP, processus qui détermine la taille de fenêtre optimale pour chaque session TCP. Dans les réseaux très efficaces, les tailles de fenêtres peuvent augmenter beaucoup car les données ne sont pas perdues. Sur les réseaux dont l’infrastructure sous-jacente est soumise à beaucoup de contraintes, la taille de fenêtre demeurera probablement réduite.</p> <p>Liens</p> <p>Vous pourrez trouver des informations détaillées sur les différentes fonctions de gestion de l’encombrement du protocole TCP dans le document RFC 2581.</p> <p><content-link target="http://www.ietf.org/rfc/rfc2581.txt" type="external">http://www.ietf.org/rfc/rfc2581.txt</content-link></p></content-text>
</page>
</topic>
</section>
<section type="" id="tl0604040000">
<title><content-text>Protocole UDP : des communications avec peu de surcharge</content-text></title>
<topic type="" id="tl0604040100">
<title><content-text>UDP : faible surcharge contre fiabilité</content-text></title>
<page type="OneColumn" id="tl0604040101">
<content-media type="StaticGraphic" id="cm9624919054"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040100/tl0604040101/cm9624919054.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040100/tl0604040101/cm9624919054text.xml"/></content-media>
<content-text><p>Le protocole UDP est un protocole simple offrant des fonctions de couche transport de base. Il crée beaucoup moins de surcharge que le protocole TCP car il est sans connexion et ne propose pas de mécanismes sophistiqués de retransmission, de séquençage et de contrôle de flux.</p> <p>Mais cela ne signifie pas que les applications utilisant le protocole UDP manquent toujours de fiabilité. Cela signifie simplement que ces fonctions ne sont pas fournies par le protocole de la couche transport et qu’elles doivent être implémentées à un autre niveau, le cas échéant.</p> <p>Bien que le volume total de trafic UDP trouvé sur un réseau classique soit relativement faible, des protocoles importants de la couche application utilisent le protocole UDP, notamment :</p> <ul><li> Système de noms de domaine (DNS)</li> <li> SNMP (Simple Network Management Protocol)</li> <li> DHCP (Dynamic Host Configuration Protocol)</li> <li> RIP (Routing Information Protocol)</li> <li> TFTP (Trivial File Transfer Protocol)</li> <li> Jeux en ligne</li></ul> <p>Certaines applications, comme les jeux en ligne ou la voix sur IP, peuvent tolérer la perte d’une certaine quantité de données. Si ces applications utilisaient le protocole TCP, elles risqueraient d’être confrontées à de longs délais pendant que le protocole TCP détecterait les pertes de données et retransmettrait les données. Ces délais seraient plus préjudiciables à l’application que la perte d’une petite quantité de données. Certaines applications, comme le système DNS, se contentent simplement de répéter leur requête si elles ne reçoivent pas de réponse. Elles n’ont donc pas besoin du protocole TCP pour garantir la livraison du message.</p> <p>La faible surcharge qu’engendre le protocole UDP rend celui-ci très intéressant pour de telles applications.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604040200">
<title><content-text>Réassemblage de datagrammes UDP</content-text></title>
<page type="OneColumn" id="tl0604040201">
<content-media type="StaticGraphic" id="cm8289536631"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040200/tl0604040201/cm8289536631.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040200/tl0604040201/cm8289536631text.xml"/></content-media>
<content-text><p>Comme le protocole UDP n’est pas orienté connexion, les sessions ne sont pas établies avant que la communication n’ait lieu comme c’est le cas avec le protocole TCP. Le protocole UDP est connu pour être un protocole basé sur les transactions. En d’autres termes, quand une application doit envoyer des données, elle les envoie tout simplement.</p> <p>De nombreuses applications utilisant le protocole UDP envoient de petites quantités de données pouvant tenir dans un seul segment. Cependant, certaines applications envoient des volumes de données plus importants qui doivent être découpés en plusieurs segments. L’unité de données de protocole UDP est appelée un <i>datagramme</i>, bien que les termes <i>segment</i> et <i>datagramme</i> soient souvent utilisés l’un pour l’autre pour décrire une unité de données de protocole de la couche transport.</p> <p>Quand plusieurs datagrammes sont envoyés vers une destination, ils peuvent emprunter des chemins différents et arriver dans le désordre. Le protocole UDP n’effectue pas de suivi des numéros d’ordre comme le fait le protocole TCP. Il n’a en effet aucun moyen de réordonnancer les datagrammes pour leur faire retrouver leur ordre de transmission d’origine. Reportez-vous à la figure.</p> <p>Le protocole UDP se contente donc de réassembler les données dans l’ordre dans lequel elles ont été reçues, puis de les transmettre à l’application. Si l’application attache une grande importance à l’ordre des données, elle devra identifier l’ordre correct des données et déterminer leur mode de traitement.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604040300">
<title><content-text>Processus et requêtes des serveurs UDP</content-text></title>
<page type="OneColumn" id="tl0604040301">
<content-media type="StaticGraphic" id="cm5610122475"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040300/tl0604040301/cm5610122475.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040300/tl0604040301/cm5610122475text.xml"/></content-media>
<content-text><p>Comme c’est le cas avec des applications basées sur le protocole TCP, des numéros de port réservés sont affectés aux applications serveur basées sur le protocole UDP. Quand ces applications ou processus s’exécutent, ils ou elles acceptent les données correspondant au numéro de port attribué. Quand le protocole UDP reçoit un datagramme destiné à l’un de ces ports, il transmet les données applicatives à l’application appropriée d’après son numéro de port.</p></content-text>
</page>
</topic>
<topic type="" id="tl0604040400">
<title><content-text>Processus des clients UDP</content-text></title>
<page type="OneColumn" id="tl0604040401">
<content-media type="StaticGraphic" id="cm5470588295"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040400/tl0604040401/cm5470588295.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040400/tl0604040401/cm5470588295text.xml"/></content-media>
<content-text><p>Comme c’est le cas avec le protocole TCP, la communication entre le client et le serveur est initiée par une application cliente qui demande des données à un processus serveur. Le processus client UDP sélectionne un numéro de port aléatoire dans une plage dynamique de numéros de ports et il l’utilise comme port source pour la conversation. Le port de destination est généralement le numéro de port réservé affecté au processus serveur. </p> <p>Le choix aléatoire des numéros de port source présente également un avantage en matière de sécurité. Quand il existe un modèle prévisible de sélection du port de destination, il est plus facile pour un intrus de simuler un accès à un client en tentant de se connecter au numéro de port le plus susceptible d’être ouvert.</p> <p>Étant donné que le protocole UDP ne crée pas de session, dès que les données sont prêtes à être envoyées et que les ports sont identifiés, il peut créer le datagramme et le soumettre à la couche réseau pour son adressage et son envoi sur le réseau.</p> <p>Souvenez-vous qu’une fois qu’un client a choisi le port source et le port de destination, la même paire de ports est utilisée dans l’en-tête de tous les datagrammes employés dans la transaction. Quand des données sont renvoyées du serveur vers le client, les numéros de port source et de port de destination sont inversés dans l’en-tête du datagramme.</p></content-text>
</page>
<page type="OneColumn" id="tl0604040402">
<content-media type="ActivityPKA" id="cm5755548362"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040400/tl0604040402/cm5755548362/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604040000/tl0604040400/tl0604040402/cm5755548362/icontext.xml"/></content-media>
<content-text><p>Cet exercice examine la façon dont le protocole DNS utilise le protocole UDP. </p><p><b>Cliquez sur l’icône Packet Tracer pour lancer l’exercice Packet Tracer.</b></p></content-text>
</page>
</topic>
</section>
<section type="" id="tl0604050000">
<title><content-text>Travaux pratiques</content-text></title>
<topic type="" id="tl0604050100">
<title><content-text>Étude des protocoles TCP et UDP à l’aide de Netstat</content-text></title>
<page type="OneColumn" id="tl0604050101">
<content-media type="ActivityLab" id="cm6014232153"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050100/tl0604050101/cm6014232153/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050100/tl0604050101/cm6014232153/icontext.xml"/></content-media>
<content-text><p>Au cours de ces travaux pratiques, vous allez examiner la commande <span class="cmd"><b>netstat</b></span> (network statistics utility) sur un ordinateur hôte et régler les options de sortie de <span class="cmd"><b>netstat</b></span> afin d’analyser et de comprendre l’état du protocole TCP/IP de la couche transport.</p><p><b>Cliquez sur l’icône des travaux pratiques pour afficher plus de détails.</b></p></content-text>
</page>
</topic>
<topic type="" id="tl0604050200">
<title><content-text>Protocoles TCP et UDP de la couche transport TCP/IP</content-text></title>
<page type="OneColumn" id="tl0604050201">
<content-media type="ActivityLab" id="cm5665071033"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050200/tl0604050201/cm5665071033/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050200/tl0604050201/cm5665071033/icontext.xml"/></content-media>
<content-text><p>Au cours de ces travaux pratiques, vous allez utiliser Wireshark pour capturer et identifier le fonctionnement et les champs d’en-tête TCP pendant une session FTP, ainsi que le fonctionnement et les champs d’en-tête UDP pendant une session TFTP.</p><p><b>Cliquez sur l’icône des travaux pratiques pour afficher plus de détails.</b></p></content-text>
</page>
</topic>
<topic type="" id="tl0604050300">
<title><content-text>Protocoles de la couche application et de la couche transport</content-text></title>
<page type="OneColumn" id="tl0604050301">
<content-media type="ActivityLab" id="cm3014762274"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050300/tl0604050301/cm3014762274/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050300/tl0604050301/cm3014762274/icontext.xml"/></content-media>
<content-text><p>Au cours de ces travaux pratiques, vous allez utiliser Wireshark pour surveiller et analyser les communications d’une application cliente (FTP et HTTP) entre un serveur et des clients.</p><p><b>Cliquez sur l’icône des travaux pratiques pour afficher plus de détails.</b></p></content-text>
</page>
<page type="OneColumn" id="tl0604050302">
<content-media type="ActivityPKA" id="cm4324308257"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050300/tl0604050302/cm4324308257/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050300/tl0604050302/cm4324308257/icontext.xml"/></content-media>
<content-text><p>Au cours de ces travaux pratiques, vous allez utiliser le mode Simulation de Packet Tracer pour capturer et analyser les paquets demandés par un site Web à l’aide d’une URL.</p><p><b>Cliquez sur l’icône Packet Tracer pour lancer l’exercice Packet Tracer.</b></p></content-text>
</page>
</topic>
</section>
<section type="ChapterSummary" id="tl0604060000">
<title><content-text>Résumé du chapitre</content-text></title>
<topic type="" id="tl0604060100">
<title><content-text>Résumé et révision</content-text></title>
<page type="OneColumn" id="tl0604060101">
<content-media type="StaticGraphic" id="cm1262585397"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060101/cm1262585397.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060101/cm1262585397text.xml"/></content-media>
<content-text><p>La couche transport fournit les données dont le réseau a besoin en :</p> <ul><li> Divisant en segments les données reçues d’une application ;</li> <li> Ajoutant un en-tête pour identifier et gérer chaque segment ;</li> <li> Utilisant les informations de l’en-tête pour réassembler les segments en données d’application ;</li> <li> Transférant les données assemblées à l’application adéquate.</li></ul> <p>Les protocoles UDP et TCP sont couramment utilisés en tant que couche transport.</p> <p>Les datagrammes UDP et les segments TCP ajoutent aux données des préfixes, composés d’en-têtes contenant un numéro de port source et un numéro de port de destination. Ces numéros de port permettent d’orienter les données vers l’application correcte s’exécutant sur l’ordinateur de destination.</p> <p>Le protocole TCP ne transmet aucune donnée au réseau tant qu’il n’a pas la confirmation que la destination est prête à les recevoir. Le protocole TCP gère alors le flux de données et renvoie tout segment de données pour lequel la destination n’a pas envoyé d’accusé de réception. TCP utilise divers mécanismes comme les connexions en trois étapes, les minuteurs, les accusés de réception et le fenêtrage dynamique pour assurer la fiabilité de ces fonctions. Néanmoins, cette fiabilité impose une surcharge au réseau car elle crée des en-têtes de segments beaucoup plus volumineux et accroît le trafic réseau entre la source et la destination qui gèrent le transport des données.</p> <p>Si les données d’application doivent être rapidement livrées à travers le réseau, ou si la bande passante du réseau ne peut pas prendre en charge la surcharge représentée par les messages de contrôle échangés entre les systèmes source et de destination, les développeurs préfèrent recourir au protocole UDP pour la couche transport. Ceci s’explique par le fait que le protocole UDP n’effectue pas de suivi, et n’accuse pas réception des datagrammes parvenus à leur destination. Il se contente de transmettre les datagrammes reçus à la couche application dans l’ordre de leur arrivée et il ne réexpédie pas les datagrammes perdus. Ceci n’implique pourtant pas nécessairement que la communication elle-même n’est pas fiable car les protocoles et services de la couche application peuvent comporter des mécanismes permettant de traiter les datagrammes perdus ou retardés si l’application l’exige.</p> <p>Les développeurs d’applications choisissent le protocole de la couche transport répondant le mieux aux exigences des utilisateurs. Ces développeurs n’oublient pas, cependant, que les autres couches jouent un rôle dans les communications sur les réseaux de données et qu’elles influencent leurs performances.</p></content-text>
</page>
<page type="FullScreen" id="tl0604060102">
<content-media type="ChapterSummary" id="cm9371573563"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060102/cm9371573563.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060102/cm9371573563text.xml"/></content-media>
<content-text></content-text>
</page>
<page type="OneColumn" id="tl0604060103">
<content-media type="ActivityPKA" id="cm1581086500"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060103/cm1581086500/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604060000/tl0604060100/tl0604060103/cm1581086500/icontext.xml"/></content-media>
<content-text><p>Dans cet exercice, vous allez étudier en détail un processus qui se produit chaque fois que vous demandez une page Web sur Internet, à savoir les interactions entre les protocoles DNS, HTTP, UDP et TCP. </p> <p><content-link target="E1_PTAct_4_6_1_Directions.pdf" type="internalfile">Instructions d’intégration des compétences Packet Tracer (PDF)</content-link></p><p><b>Cliquez sur l’icône Packet Tracer pour lancer l’exercice Packet Tracer.</b></p></content-text>
</page>
<page type="OneColumn" id="tl0604060104">
<content-media type="StaticGraphic" id="cm4983274047"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060104/cm4983274047.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060104/cm4983274047text.xml"/></content-media>
<content-text><p><b>Pour en savoir plus</b></p> <p><b>Questions de réflexion</b></p> <p>Déterminez quelles exigences d’une application de la couche application conduiraient les développeurs de cette application à choisir le protocole UDP ou le protocole TCP en tant que protocole utilisé par la couche transport.</p> <p>Si une application réseau avait besoin que ses données soient livrées de façon fiable, indiquez comment le protocole UDP pourrait être choisi comme protocole de la couche transport et dans quelles circonstances il serait utilisé. </p> <p><b>Liens</b></p> <p>Présentation de l’interconnexion de réseaux</p> <p><content-link target="http://www.cisco.com/en/US/docs/internetworking/technology/handbook/Intro-to-Internet.html" type="external">http://www.cisco.com/en/US/docs/internetworking/technology/handbook/Intro-to-Internet.html</content-link></p></content-text>
</page>
</topic>
</section>
<section type="ChapterQuiz" id="tl0604070000">
<title><content-text>Questionnaire du chapitre</content-text></title>
<topic type="" id="tl0604070100">
<title><content-text>Questionnaire du chapitre</content-text></title>
<page type="FullScreen" id="tl0604070101">
<content-media type="ChapterQuiz" id="cm1086891551"><title><content-text></content-text></title><media ref="tl0604000000/tl0604070000/tl0604070100/tl0604070101/cm1086891551/" mime="" scale="true" type="directory" width="100%" height="100%" external="tl0604000000/tl0604070000/tl0604070100/tl0604070101/cm1086891551/icontext.xml"/></content-media>
<content-text></content-text>
</page>
</topic>
</section>
</chapter>
